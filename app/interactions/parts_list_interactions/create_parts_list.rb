# TODO:
#
# For v1:
# 1. Set up the tinypng API, and pass all images to it before uploading to S3. I'll have to pay for a
# $15 1 month subscription so I can convert up to 3500 images.
# 2. Come up with some code that deals specifically with the pieces that we have
# to put together in pieces, such as flowers and stems, hinge base and hinge base
# control stick, hinge plates, etc. The code should offer to combine the pieces
# into a single piece, but not force it. This can be done in part using BLs API.
# Will need to extend my usage of BL API for this, to make calls to the subset/superset calls.
# Will want to do that for each new part, check if it's part of a subset/superset.
# 3. Determine if a part is something generated by LSynth, and give Brian the option to
  # manually select the part from a select, and select the length, if appropriate.
# 4. After everything has been done in here, the user needs to be presented with a
  # form with all the parts, where they are given the option to edit part #, color, qty,
  # image, add a BL ID in the case the ldraw ID isn't used by BL. The user should
  # be able to request a new image from BL (which they might
  # want to do after correcting a part # or color #), or save a url to the
  # image here if the one displayed is not satisfactory.

# Workflow:
# * User submits XML or .ldr
# * Backend does a quick check to make sure it can parse the input before proceeding to generate images, etc.
# * Backend stores new part and part/color info and retrieves images from Bricklink/Rebrickable, etc.
# * User gets a confirmation page where they can edit or approve, or upload images for part/colors that couldn't get an image.
  # Confirmation page will have info about parts availability and flag anything too expensive,
  # or too rare, or obsolete. User can save progress on parts list. If something is part
  # of a subset, or can be combined into a superset, flag it.
# * User can identify primary/secondary colors for the model to see what additional colors
  # the model can be built in.
# User can see Lsynthed parts and update appropriately.
# * User will preview and approve parts list.

# Subscription user will have the ability to get an estimate for BrickOwl, and possibly for Bricklink
# Parts list user will have the ability to adjust part quality on a parts-list wide or at part/color level.

# PartsListInteractions::CreatePartsList.run(parts_list_id: 2)

module PartsListInteractions
  class CreatePartsList < BasePartsListInteraction
    def run
      parts_list = PartsList.find(@parts_list_id)
      parts = if parts_list.bricklink_xml.present?
                BricklinkXmlParser.new(parts_list.bricklink_xml).parse
              else
                LdrParser.new(parts_list.ldr).parse
              end

      parts.each do |key, values|
        # TODO: In here, (or before if possible, after if necessary) assign the following values:
        # bl_part_num, part_name, color_name, image_link (OR) sprite_position
        # If I do a sprite sheet, will have to do it after this block, after images
        # have been retrieved. Don't need to save sprite position, as the css that's
        # generated will reference image by filename, so it will be pulling the guid,
        # which conveniently is already being stored for the element.
        # Not sure I'm going to do the spritesheet
        part = Part.find_or_create_via_external(key) # TODO: Pass along whether this is an LSynth part or not.
        element = Element.find_or_create_via_external(key)
        color = Color.find(element.color_id)

        parts[key]['color_name'] = color.bl_name
        parts[key]['part_name'] = part.name
        parts[key]['bl_part_num'] = part.bl_id
        parts[key]['guid'] = element.guid
        parts[key]['image_url'] = element.image.url

        Lot.create(parts_list_id: parts_list.id, element_id: element.id, quantity: values['quantity'])
      end

      # TODO: By the time I get here, I should have completely assembled the parts
      # hash with all the desired keys, including names, image links, sprite sheet positions, etc.
      parts_list.parts = parts
      parts_list.save!
    rescue StandardError => e
      self.error = e
      Rails.logger.error("PartsList::CreatePartsList::#{@parts_list_id}\nERROR: #{e}\nBACKTRACE: #{e.backtrace}")
    end
  end
end
